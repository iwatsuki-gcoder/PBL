#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>

#define MAX 50

typedef struct {
    int pid;
    int arrival;
    int burst;
    int remaining;
    int priority;
    int start;
    int completion;
    int waiting;
    int turnaround;
    bool done;
} Process;

// Function declarations
void inputProcesses(Process p[], int *n);
void printTable(Process p[], int n);
void reset(Process p[], int n);
void fcfs(Process p[], int n);
void sjf(Process p[], int n);
void srtf(Process p[], int n);
void priorityScheduling(Process p[], int n);
void roundRobin(Process p[], int n, int quantum);
void calculateMetrics(Process p[], int n);
void showMenu();

// Utility function to sort by arrival time
void sortByArrival(Process p[], int n) {
    for (int i=0; i<n-1; i++)
        for (int j=i+1; j<n; j++)
            if (p[i].arrival > p[j].arrival) {
                Process tmp = p[i];
                p[i] = p[j];
                p[j] = tmp;
            }
}

// Input
void inputProcesses(Process p[], int *n) {
    printf("\nEnter number of processes: ");
    scanf("%d", n);
    for (int i=0; i<*n; i++) {
        printf("\nEnter details for Process %d\n", i+1);
        p[i].pid = i+1;
        printf("Arrival Time: "); scanf("%d", &p[i].arrival);
        printf("Burst Time: ");   scanf("%d", &p[i].burst);
        printf("Priority: ");     scanf("%d", &p[i].priority);
        p[i].remaining = p[i].burst;
        p[i].done = false;
    }
}

// Reset metrics
void reset(Process p[], int n) {
    for (int i=0; i<n; i++) {
        p[i].remaining = p[i].burst;
        p[i].done = false;
        p[i].completion = p[i].waiting = p[i].turnaround = 0;
        p[i].start = -1;
    }
}

// Print metrics table
void printTable(Process p[], int n) {
    printf("\nPID\tAT\tBT\tPR\tST\tCT\tTAT\tWT");
    double avgTAT=0, avgWT=0;
    for (int i=0; i<n; i++) {
        p[i].turnaround = p[i].completion - p[i].arrival;
        p[i].waiting = p[i].turnaround - p[i].burst;
        avgTAT += p[i].turnaround;
        avgWT += p[i].waiting;
        printf("\nP%d\t%d\t%d\t%d\t%d\t%d\t%d\t%d",
            p[i].pid, p[i].arrival, p[i].burst, p[i].priority,
            p[i].start, p[i].completion, p[i].turnaround, p[i].waiting);
    }
    printf("\nAverage Turnaround Time = %.2f", avgTAT/n);
    printf("\nAverage Waiting Time = %.2f\n", avgWT/n);
}

// ===== Algorithms =====

// FCFS
void fcfs(Process p[], int n) {
    sortByArrival(p,n);
    int time = 0;
    for (int i=0; i<n; i++) {
        if (time < p[i].arrival) time = p[i].arrival;
        p[i].start = time;
        time += p[i].burst;
        p[i].completion = time;
    }
    printf("\n--- FCFS Scheduling ---\n");
    printTable(p,n);
}

// SJF (Non-preemptive)
void sjf(Process p[], int n) {
    sortByArrival(p,n);
    int time = 0, completed = 0;
    while (completed < n) {
        int idx = -1, minBurst = 1e9;
        for (int i=0; i<n; i++) {
            if (!p[i].done && p[i].arrival <= time && p[i].burst < minBurst) {
                minBurst = p[i].burst;
                idx = i;
            }
        }
        if (idx == -1) { time++; continue; }
        p[idx].start = time;
        time += p[idx].burst;
        p[idx].completion = time;
        p[idx].done = true;
        completed++;
    }
    printf("\n--- SJF (Non-Preemptive) Scheduling ---\n");
    printTable(p,n);
}

// SRTF (Preemptive SJF)
void srtf(Process p[], int n) {
    sortByArrival(p,n);
    int time=0, completed=0, minRemaining, idx;
    while (completed < n) {
        idx=-1; minRemaining = 1e9;
        for (int i=0;i<n;i++){
            if(!p[i].done && p[i].arrival<=time && p[i].remaining<minRemaining){
                minRemaining=p[i].remaining; idx=i;
            }
        }
        if(idx==-1){ time++; continue; }
        if(p[idx].start==-1) p[idx].start=time;
        p[idx].remaining--;
        time++;
        if(p[idx].remaining==0){
            p[idx].completion=time;
            p[idx].done=true;
            completed++;
        }
    }
    printf("\n--- SRTF (Preemptive SJF) Scheduling ---\n");
    printTable(p,n);
}

// Priority Scheduling (Preemptive)
void priorityScheduling(Process p[], int n) {
    sortByArrival(p,n);
    int time=0, completed=0;
    while (completed<n) {
        int idx=-1, highest=1e9;
        for (int i=0;i<n;i++){
            if(!p[i].done && p[i].arrival<=time && p[i].priority<highest){
                highest=p[i].priority; idx=i;
            }
        }
        if(idx==-1){ time++; continue; }
        if(p[idx].start==-1) p[idx].start=time;
        p[idx].remaining--;
        time++;
        if(p[idx].remaining==0){
            p[idx].completion=time;
            p[idx].done=true;
            completed++;
        }
    }
    printf("\n--- Priority (Preemptive) Scheduling ---\n");
    printTable(p,n);
}

// Round Robin
void roundRobin(Process p[], int n, int quantum) {
    sortByArrival(p,n);
    int time=0, done=0;
    int queue[MAX], front=0, rear=0;
    int inQueue[MAX]={0};

    while(done<n){
        // add newly arrived
        for(int i=0;i<n;i++)
            if(!inQueue[i] && !p[i].done && p[i].arrival<=time){
                queue[rear++]=i; inQueue[i]=1;
            }

        if(front==rear){ time++; continue; }

        int cur = queue[front++];
        if(p[cur].start==-1) p[cur].start=time;
        int exec = (p[cur].remaining>quantum)?quantum:p[cur].remaining;
        p[cur].remaining -= exec;
        time += exec;

        for(int i=0;i<n;i++)
            if(!inQueue[i] && !p[i].done && p[i].arrival<=time){
                queue[rear++]=i; inQueue[i]=1;
            }

        if(p[cur].remaining==0){
            p[cur].completion=time; p[cur].done=true; done++;
        } else {
            queue[rear++]=cur;
        }
    }
    printf("\n--- Round Robin Scheduling (q=%d) ---\n", quantum);
    printTable(p,n);
}

// ===== Main menu =====
void showMenu() {
    printf("\n==============================");
    printf("\n   TASK SCHEDULING SYSTEM");
    printf("\n==============================");
    printf("\n1. FCFS");
    printf("\n2. SJF (Non-preemptive)");
    printf("\n3. SRTF (Preemptive)");
    printf("\n4. Priority (Preemptive)");
    printf("\n5. Round Robin");
    printf("\n6. Exit");
    printf("\n==============================\n");
}

int main() {
    Process p[MAX];
    int n, choice, quantum;
    inputProcesses(p, &n);

    while (1) {
        showMenu();
        printf("Enter your choice: ");
        scanf("%d", &choice);
        reset(p,n);

        switch(choice) {
            case 1: fcfs(p,n); break;
            case 2: sjf(p,n); break;
            case 3: srtf(p,n); break;
            case 4: priorityScheduling(p,n); break;
            case 5:
                printf("Enter Time Quantum: ");
                scanf("%d", &quantum);
                roundRobin(p,n,quantum);
                break;
            case 6: printf("\nExiting... Goodbye!\n"); exit(0);
            default: printf("\nInvalid choice!\n");
        }
    }
    return 0;
}
